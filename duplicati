#!/bin/bash
source /opt/duplicati_helper/duplicati.conf


####
# This file is intended to give a more natural interface to the duplicati command
# line interface, simplifying automated backups.
####

main () { 
    if [ "$HELPER_AUTO_UPDATE" = "true" ] ; then
        update_helper $@
    fi

    if [ "$1" = "command" ] ; then
        ## Run duplicati with the provided arguments
            shift
            ${DUPLICATI} $@
            exit_duplicati $? "command"
    elif [ "$1" = "server" ] ; then
        ## Start the Webserver
            ${DUPLICATI_SERVER} --webservice-port=${SERVER_PORT} --webservice-interface=* --webservice-password=${SERVER_PAS}
            exit_duplicati $? "server"
    elif [ "$1" = "usage" ] ; then
        ## Show usage of running duplicati processes using top
            duplicati_usage
    elif [ "$1" = "status" ] ; then
        ## Show the status, displayed 
            duplicati_status $2
    elif [ "$#" -lt 2 ] ; then 
        ## If provided arguments do not fit, show help
            help
    elif ( [ "$1" == "repair" ] || [ "$1" == "backup" ] ) ; then
        ## Backup or repair specified backup
            run_duplicati $1 $2 $3
    elif ( [ "$1" == "kill" ] ) ; then
        ## Kill running duplicati process
            kill_duplicati $2
    fi
}

# Choses the right backup config and starts it
# $1: "repair" or "backup" depending
# $2: name of backup 
# $3: 'quiet', optional
run_duplicati () {

    # Load the correct configuration
    while read -r name path pas excl ; do
        if [[ $name == \#* ]] ; then
            # Ignore lines with pound
            continue
        elif [ $2 = $name ] ; then
            # If this is the choosen backup, start backup
            break
        else
            # Clear name, in case it did not match
            name=""
        fi
    done < "${BACKUP_CONFIG}"
    
    # If no config was found, exit
    if [ -z $name ] ; then
        echo "No backup config fig with name $2 found!"
        echo
        help
    fi

    # Check if backup is allready running
    THIS_DUPLICATI_PID="${PID_DIR}${DUPLICATI_PID_PREFIX}.${name}.pid"

    if [ -e ${THIS_DUPLICATI_PID} ] ; then
        if ps -p $(cat $THIS_DUPLICATI_PID) > /dev/null ; then
            ## If duplicati is currently performing a backup you can't start another one
            echo "Duplicati already running"
            exit_duplicati 5 $1 ${name}
        else
            ## If there is a PID file, but no running process delete the pid file
            rm $THIS_DUPLICATI_PID
        fi
    fi

    # Building arguments

    # 1) Remote directory
    DUPLICATI_ARG="${BASE_URL}/${name}"
    
    # 2) Repair or backup
    if [ "$1" = "repair" ] ; then
        DUPLICATI_ARG="repair ${DUPLICATI_ARG}"
    elif [ "$1" = "backup" ] ; then
        DUPLICATI_ARG="backup ${DUPLICATI_ARG} ${path}"
    else
        help
    fi

    # 3) Backup name and prefix
    DUPLICATI_ARG="${DUPLICATI_ARG} --backup-name=\"${name}\" --prefix=\"${name}\""

    # 4) Set passphrase
    DUPLICATI_ARG="${DUPLICATI_ARG} --passphrase=\"${pas}\""

    # 5) Set log settings
    THIS_LOG_PATH="${LOG_PATH}${LOG_PREFIX}.${name}.log"
    THIS_CLI_LOG_PATH="${LOG_PATH}${LOG_PREFIX}.${name}.cli.log"
    DUPLICATI_ARG="${DUPLICATI_ARG} --log-file=\"${THIS_LOG_PATH}\" --log-level=\"${LOG_LEVEL}\""

    # 6) Add fixed parameters
    DUPLICATI_ARG="${DUPLICATI_ARG} --authid=\"${AUTH_ID}\" ${COMPRESSION_MODULE} ${ENCRYPTION_MODULE} ${BACKUP_MODULE}" 

    # 7) Add optional excludes
    DUPLICATI_ARG="${DUPLICATI_ARG} ${excl}"

    # 8) Check if quite flag is set, not working at the moment, duplicati gives a weird error about non-existing source folders
#    if [ "$3" = "quiet" ] ; then
#        DUPLICATI_ARG="${DUPLICATI_ARG} --quiet-console=true >> ${THIS_CLI_LOG_PATH} 2>&1"
#    fi

    # Running command
    ${DUPLICATI} ${DUPLICATI_ARG} & echo $! > ${THIS_DUPLICATI_PID}

    if [ "$3" = "quiet" ] ; then
        fdswap $(cat ${THIS_DUPLICATI_PID}) ${THIS_CLI_LOG_PATH}
    fi

    wait $(cat ${THIS_DUPLICATI_PID}) 
    success=$?
    rm ${THIS_DUPLICATI_PID}

    exit_duplicati $success $1 ${name}
}

# Kills a running instance of duplicati
# $1: Name of the backup instance
kill_duplicati () {
    THIS_DUPLICATI_PID="${PID_DIR}${DUPLICATI_PID_PREFIX}.$1.pid"

    if [ -e ${THIS_DUPLICATI_PID} ] && ps -p $(cat ${THIS_DUPLICATI_PID}) > /dev/null ; then
        sudo kill -9 $(cat ${THIS_DUPLICATI_PID})
        sleep 1
        
        if [ -e ${THIS_DUPLICATI_PID} ] ; then
            rm -f ${THIS_DUPLICATI_PID}
        fi

        exit_duplicati 4 "job" $1
    else
        # Duplicati is not running, can't kill it
            echo "Duplicati not running"
            exit_duplicati 3 "kill" $1
    fi
}

# Shows the usage of all running duplicati jobs using top
duplicati_usage () {
    DUPLICATI_PIDS="${PID_DIR}${DUPLICATI_PID_PREFIX}.*"

    if ls ${DUPLICATI_PIDS} 1> /dev/null 2>&1; then
        TOP_CMD="top -c "

        for f in ${DUPLICATI_PIDS} ; do
            TOP_CMD="${TOP_CMD} -p $(cat $f)"
        done

        ${TOP_CMD}
    else
        echo "No instance of duplicati is running" 
    fi
    
    exit_duplicati 1 "usage"
}

# If invoked without any arguments, showing the status summary as provided by duplicatirc.
# If a single argument is provided, the current log output of this job is shown using tail.
duplicati_status () {
    if [ -z $1 ] ; then
        source $DUPLICATIRC
    else
       tail -f ${LOG_PATH}${LOG_PREFIX}.$1.*  
    fi
    exit_duplicati 1 "status"
}

# This function checks if there is an update available for the helper and installs the update
# Arguments: The arguments of the initial run 
update_helper () {
    CURRENT_DIR=$(pwd)
    GIT_DIR=$(dirname $(readlink -f $0))

    cd $GIT_DIR

    echo -n "Checking for duplicati_helper updates..." 
    git remote update > /dev/null 2> /dev/null
    if [ $? -eq 0 ]; then
        LOCAL=$(git rev-parse @{0})
        REMOTE=$(git rev-parse @{u})

        if [ $LOCAL != $REMOTE ]; then
            echo -n "\nUpdating duplicati_helper and restarting command..."
            git pull > /dev/null 2> /dev/null
            cd $CURRENT_DIR
            exec $0 $@
            echo "done"
            exit
        else
            echo "no update available"
            echo
        fi
    else
        echo "unable to get update, try again later"
        echo
    fi

    cd $CURRENT_DIR
}

help () {
    echo "Usage: "
    echo "  Backup/Repair:  $0 {repair | backup} <backup name> { quiet | }" 
    echo "      Currently configured backups:"
    
    while read -r name path pas excl ; do
        if [[ $name == \#* ]] ; then
            # Ignore lines with pound
            continue
        else
            echo "          ${name}: ${path}"
        fi
    done < "${BACKUP_CONFIG}"

    echo "      Optional parameter 'quiet' will relay all output to ${DUPLICATI_LOG}"
    echo "  Kill:           $0 kill <backup name>"
    echo "      Kills the specified backup job"
    echo "  Server:         $0 server"
    echo "      The duplicati webinterface is started on port ${SERVER_PORT} with password '${SERVER_PAS}'"
    echo "  Usage:          $0 usage"
    echo "      Shows the usage of all running duplicati jobs using top"
    echo "  Status:         $0 status"
    echo "      Shows the status table, shown during log in"
    echo "  Job status:     $0 status <backup name>"
    echo "      Shows the live log output of the specified job, using tail"
    echo "  Duplicati:      $0 command"
    echo "      The duplicati command line interface is started with all arguments that follow 'command'"
    exit_duplicati 3 "help"
}

# Exits duplicati and writes the result to the status file
# $1 Exit code: 
#   0: Successfull
#   1: Successfull, but backup didn't change anything
#   2: Successfull, with warnings
#   3: Not successfull, wrong syntax
#   4: Not successfull, instance killed
#   5: Not successfull, another instance was allready running
# $2 Backup job function (e.g. repair, backup...)
# $3 Backup job name, optional
exit_duplicati () {
    STATUS=""
    JOB_FUNC="$2"
    JOB_NAME="$3"
    JOB_TIME="$(date +'%Y-%m-%d_%H:%M:%S')"
 
    case "$1" in
        0)
            STATUS="${JOB_FUNC} successful" ;;
        1)
            STATUS="${JOB_FUNC} successful [no files were changed]" ;;
        2)
            STATUS="${JOB_FUNC} successful [with warnings]" ;;
        3)
            STATUS="${JOB_FUNC} NOT successful [wrong syntax]" ;;
        4)
            STATUS="${JOB_FUNC} NOT successful [instance was killed]" ;;
        5)
            STATUS="${JOB_FUNC} NOT successful [instance was already running]" ;;
        100)
            STATUS="${JOB_FUNC} NOT successful [repair required]" ;;
        *)
            STATUS="${JOB_FUNC} NOT successful" ;;
    esac

    if [ -z $JOB_NAME ] ; then
        # Write to log
        echo "${JOB_TIME}: Duplicati finished ${STATUS}" >> "${LOG_PATH}${LOG_PREFIX}.log"
    else
        # Write to log
        echo "${JOB_TIME}: Job \"${JOB_NAME}\" finished ${STATUS}" >> "${LOG_PATH}${LOG_PREFIX}.${JOB_NAME}.log"

        # Modify status file unless status code is 3 or 5
        if [ "$1" -ne 3 ] && [ "$1" -ne 5 ] ; then

            touch ${BACKUP_STATUS_FILE}
            chmod ugo+rw ${BACKUP_STATUS_FILE} 
    
            # 1) Delete earlier status of this job
            sed -i '/^\(+\|-\)'" ${JOB_NAME}"' /d' ${BACKUP_STATUS_FILE}
    
            # 2) Add new status
            echo "+ ${JOB_NAME} ${JOB_TIME} ${STATUS} {Code: $1}" >> ${BACKUP_STATUS_FILE}
        fi
    fi 
    
    exit $1
}

# This function exchanges file descriptors of running processes using gdb, this is a workaround, since standard relaying (using <<) does not seem to work with duplicati.
# This script is based on a script by Robert McKay and modified by Ingvar Hagelund 
# $1 The PID of the process
# $2 The log file
fdswap () {
    if ! gdb --version > /dev/null 2>&1; then 
        echo "Unable to find gdb, quiet mode not working!"
        return
    fi
   
    sudo -v
    if [ "$?" = 1 ] ; then
        echo "In order to write all output to a file you need to be root"
        return
    fi
    
    dst=$2
    pid=$1

    touch $dst
    (
        echo "attach $pid"
        # Open Mode is (O_RDWR | O_APPEND | O_ASYNC | O_CREAT)
        echo 'call open("'$dst'", 586, 0666)'
        # Switch stdout
        echo 'call dup2($1,1)'
        # Switch stderr
        echo 'call dup2($1,2)'
        # Close file
        echo 'call close($1)'
        echo 'detach' 
        echo 'quit'
    ) | sudo gdb -q -x - > /dev/null 2>&1
}

main $@
exit -1
